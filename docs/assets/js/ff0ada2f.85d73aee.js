"use strict";(self.webpackChunkcase_study_demo=self.webpackChunkcase_study_demo||[]).push([[815],{1246:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"Technical","title":"Technical Decisions & Challenges","description":"Automating the AWS Cloud infrastructure and designing the Control Panel for Rabbitory came with its own set of unique considerations and challenges. Below is a summary of the most salient decisions we made as a team and what challenges we encountered in building this tool.","source":"@site/docs/Technical.md","sourceDirName":".","slug":"/Technical","permalink":"/rabbitory_webpage/docs/Technical","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_label":"Technical Decisions & Challenges","sidebar_position":6},"sidebar":"tutorialSidebar","previous":{"title":"Architecture Overview","permalink":"/rabbitory_webpage/docs/ArchitectureOverview"},"next":{"title":"Future Work","permalink":"/rabbitory_webpage/docs/FutureWork"}}');var i=n(4848),a=n(8453);const o={sidebar_label:"Technical Decisions & Challenges",sidebar_position:6},r="Technical Decisions & Challenges",l={},c=[{value:"AWS EC2 vs ECS",id:"aws-ec2-vs-ecs",level:2},{value:"AWS SDK vs. CDK",id:"aws-sdk-vs-cdk",level:2},{value:"RabbitMQ Server Interactions",id:"rabbitmq-server-interactions",level:2},{value:"Challenges with the Control Panel",id:"challenges-with-the-control-panel",level:2},{value:"AWS EC2 Status Inconsistencies",id:"aws-ec2-status-inconsistencies",level:4},{value:"Badge Notifications",id:"badge-notifications",level:4},{value:"Creating Alarms on a Self-Hosted App",id:"creating-alarms-on-a-self-hosted-app",level:4},{value:"Automating HTTPS",id:"automating-https",level:2}];function d(e){const t={h1:"h1",h2:"h2",h4:"h4",header:"header",hr:"hr",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"technical-decisions--challenges",children:"Technical Decisions & Challenges"})}),"\n",(0,i.jsx)(t.p,{children:"Automating the AWS Cloud infrastructure and designing the Control Panel for Rabbitory came with its own set of unique considerations and challenges. Below is a summary of the most salient decisions we made as a team and what challenges we encountered in building this tool."}),"\n",(0,i.jsx)(t.h2,{id:"aws-ec2-vs-ecs",children:"AWS EC2 vs ECS"}),"\n",(0,i.jsx)(t.p,{children:"The first technical decision our team needed to make was on whether to host RabbitMQ servers in containers managed by ECS (Elastic Container Service) or on EC2 (Elastic Compute Cloud) instances. Choosing the ECS option would make deployments faster and scaling easier by abstracting infrastructure and managing containers for you. However, it would introduce complexity for stateful apps like RabbitMQ, and give developers less direct access to things like storage, networking, and system-level configurations. On the other hand, the EC2 option provides users full control over their servers, making it ideal for managing RabbitMQ\u2019s configuration, plugins, and storage directly. The tradeoff of using EC2 is more manual setup and maintenance, with slower provisioning and scaling as compared to containers."}),"\n",(0,i.jsx)(t.p,{children:"Rabbitory prioritizes transparency, infrastructure ownership, and simplicity in a single-instance, self-hosted context. EC2 offers the right balance of control and familiarity for users who want to own their setup without diving deep into the complexities of container orchestration. If Rabbitory expands to support RabbitMQ clustering, ECS might become a more compelling option. But for now, the EC2 option best matches Rabbitory\u2019s philosophy and needs."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"aws-sdk-vs-cdk",children:"AWS SDK vs. CDK"}),"\n",(0,i.jsx)(t.p,{children:"When deploying and interacting with AWS cloud resources, developers have the following options:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"AWS Typescript SDK"}),"\n",(0,i.jsx)(t.li,{children:"AWS CLI"}),"\n",(0,i.jsx)(t.li,{children:"AWS CloudFormation"}),"\n",(0,i.jsx)(t.li,{children:"AWS Typescript CDK"}),"\n",(0,i.jsx)(t.li,{children:"TerraForm"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"All of these options can call the AWS API to deploy resources, but only some provide the ability to also interact with resources and be used in code programmatically. Because Rabbitory needed automate AWS provisioning for our users, our team considered the two options with a programmatic interface:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"AWS Typescript SDK for both deployment and resource interactions"}),"\n",(0,i.jsx)(t.li,{children:"AWS Typescript CDK for deployment + SDK for resource interactions"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"AWS APIs",src:n(2969).A+"",width:"1024",height:"768"})}),"\n",(0,i.jsxs)(t.p,{children:["Our team ended up choosing to build with the AWS Typescript SDK, as it provided the most infrastructure flexibility and a quicker development process. This approach removed the overhead of ",(0,i.jsx)("a",{href:"https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-overview.html#cfn-concepts-stacks",target:"_blank",children:"CloudFormation stacks"})," and ",(0,i.jsx)("a",{href:"https://docs.aws.amazon.com/cdk/v2/guide/bootstrapping.html",target:"_blank",children:"CDK bootstrapping"}),", allowing Rabbitory to be both lightweight and customizable."]}),"\n",(0,i.jsx)(t.p,{children:"The tradeoffs are that Rabbitory takes on more responsibility for infrastructure modeling, permission management, and avoiding configuration drift. As Rabbitory expands its feature set, a transition to CDK for resources deployment may valuable. Terraform may also be considered instead of the CDK if Rabbitory seeks to offer more cloud platforms besides AWS."}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"rabbitmq-server-interactions",children:"RabbitMQ Server Interactions"}),"\n",(0,i.jsx)(t.p,{children:"RabbitMQ comes with a large set of utility features that allow users to customize their queues. Allowing users to access and enable these specialized features from a centralized place, like our Control Panel, is essential. To enable these features, users often need to interact with the RabbitMQ server directly. Since the Rabbitory Control Panel runs on a separate EC2 instance than the RabbitMQ EC2 instances, we needed a method for remotely controlling and configuring the RabbitMQ EC2."}),"\n",(0,i.jsxs)(t.p,{children:["One straightforward solution would be to create a custom API on each RabbitMQ instance that would accept requests and execute corresponding actions. However, running a persistent API on each RabbitMQ instance would force the instance to share system resources with other processes. According to RabbitMQ documentation, this is considered ",(0,i.jsx)("a",{href:"https://www.rabbitmq.com/docs/production-checklist#storage-isolation",target:"_blank",children:"poor practice"}),"."]}),"\n",(0,i.jsx)(t.p,{children:"Another possible solution was to download RabbitMQ\u2019s CLI tools onto the Control Panel EC2 instance to communicate with the RabbitMQ instances. This would allow the Control Panel to perform remote operations on each RabbitMQ instance without compromising the RabbitMQ instances\u2019 system performance. However, this solution would shift the system resource burden onto the Control Panel EC2."}),"\n",(0,i.jsxs)(t.p,{children:["Instead, we wanted a solution that enables remote access to these tools without duplicating infrastructure. ",(0,i.jsx)("a",{href:"https://docs.aws.amazon.com/systems-manager/latest/userguide/what-is-systems-manager.html",target:"_blank",children:"AWS SSM Session Manager"})," addressed this need by allowing users to initiate secure, remote shell sessions directly to EC2 instances. Using IAM permissions, users can safely run bash commands on remote instances without the need for persistent APIs or additional dependencies, preserving both performance and system simplicity. In Rabbitory, we utilize AWS SSM to change RabbitMQ configurations, enable plugins, and open protocol ports for individual RabbitMQ instances."]}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"SSM Communication",src:n(1257).A+"",width:"7680",height:"4320"})}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"challenges-with-the-control-panel",children:"Challenges with the Control Panel"}),"\n",(0,i.jsx)(t.h4,{id:"aws-ec2-status-inconsistencies",children:"AWS EC2 Status Inconsistencies"}),"\n",(0,i.jsx)(t.p,{children:"One challenge encountered when building Rabbitory was showing accurate instance statuses on the Control Panel homepage. AWS marks an EC2 as \u201crunning\u201d even when RabbitMQ is still starting up. To fix this, we added a custom check that polls the instance until RabbitMQ is fully ready and its config is saved to DynamoDB. Only then do we mark it as \u201crunning.\u201d Until that point, it stays in a \u201cpending\u201d state, and we block access to the instance details page."}),"\n",(0,i.jsx)(t.h4,{id:"badge-notifications",children:"Badge Notifications"}),"\n",(0,i.jsxs)(t.p,{children:["Another challenge came in creating badge notifications for Control Panel events. To build badge notifications for our Control Panel, the application needed a way to deliver real-time alerts to the frontend without requiring a page refresh. While websockets are a common choice for this kind of communication, they require a persistent server to keep the connection open. Since Next.js uses a serverless architecture, this approach wasn't a good fit. Instead, we implemented the system using ",(0,i.jsx)("a",{href:"https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events",target:"_blank",children:"server-sent events"}),", which work well in a serverless environment and allow for efficient one-way communication from the server to the client."]}),"\n",(0,i.jsx)(t.h4,{id:"creating-alarms-on-a-self-hosted-app",children:"Creating Alarms on a Self-Hosted App"}),"\n",(0,i.jsx)(t.p,{children:"Additionally, creating an Alarms Page for a self-hosted platform came with some unforeseen tradeoffs. For the Alarms Page, we wanted to allow users to integrate memory and storage alarms within their team\u2019s workplace Slack. However, since Rabbitory is self-hosted, it couldn\u2019t rely on a centralized Slack bot to send alerts to users."}),"\n",(0,i.jsxs)(t.p,{children:["To solve this problem, we chose to provide users a way to easily create their own Slack bot. On the Alarms Page, a quick tutorial is provided to guide users in creating a Rabbitory Slack bot for their alarms. Although this adds manual work for users, this approach aligns with Rabbitory\u2019s self-hosted model and allows users the convenience of receiving a Slack notification when memory and storage issues arise. Right now, Rabbitory alarms run with ",(0,i.jsx)("a",{href:"https://www.npmjs.com/package/node-cron",target:"_blank",children:"node-cron"})," on the Control Panel\u2019s EC2 instance. In the future, we\u2019re considering ",(0,i.jsx)("a",{href:"https://aws.amazon.com/eventbridge/",target:"_blank",children:"AWS EventBridge"})," to make alarms more reliable and decoupled."]}),"\n",(0,i.jsx)(t.hr,{}),"\n",(0,i.jsx)(t.h2,{id:"automating-https",children:"Automating HTTPS"}),"\n",(0,i.jsx)(t.p,{children:"Unlike Rabbitory, many self-hosted SaaS tools don\u2019t enable HTTPS by default, placing the responsibility of enabling HTTPS on the user. While this simplifies initial deployment, it requires users to manually secure their application later."}),"\n",(0,i.jsxs)(t.p,{children:["For example, Grafana, an open-source tool for monitoring and visualizing time-series data, ships with HTTP by default and leaves ",(0,i.jsx)("a",{href:"https://grafana.com/docs/grafana/latest/setup-grafana/set-up-https/",target:"_blank",children:"HTTPS setup"})," to the user. This usually means configuring DNS, installing SSL certificates, and setting up a reverse proxy like NGINX. Each step depends on the one before it, and DNS propagation can be slow or inconsistent depending on the domain provider."]}),"\n",(0,i.jsx)(t.p,{children:"Rabbitory takes a different approach. Our team automated HTTPS setup to cut down on deployment overhead. When users choose to deploy the Control Panel with HTTPS, the CLI asks for a domain the user owns, then handles the rest. It updates DNS using Route53, whether the domain is registered there or elsewhere. It sets up a hosted zone, adds A-records for the Control Panel, issues certificates with Certbot, and configures NGINX as a reverse proxy. By automating this setup, Rabbitory provides a secure, production-ready environment with minimal manual effort."}),"\n",(0,i.jsx)(t.p,{children:"[ CLI image of this here ? ]"})]})}function h(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1257:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/ssm-communication-fce62510cd297766414c0a4565ea8bdb.png"},2969:(e,t,n)=>{n.d(t,{A:()=>s});const s=n.p+"assets/images/aws-apis-940d93b84aa1e0d52d86de1139454904.svg"},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>r});var s=n(6540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);